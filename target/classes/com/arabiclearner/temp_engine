/*
 *  Copyright (c) 2021 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 *  When the lecturer login
 *  1)Get the name
 *  2)Send the name and the title to the server with json.stringify
 *  3)The server responds with a unique id; save the id
 * 
 *  2)start peer connection and create offer
 *  3)create a json object 
 *  4)add the id and the offer created to the json object
 *  5)send the stringify json object to the server
 *  6)get the response
 */

'use strict';

const configuration = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    {
      urls: 'turn:openrelay.metered.ca:80',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    }
  ]
};

const prot = window.location.protocol;
const host = window.location.host;

var sidePanel = document.getElementById("targetDiv1");

//1)Get the name 
const nm = document.getElementsByTagName("header")[0].textContent;

//2)send the name and title to the server
let jsonObject = {name: nm, title: "Student"};
sendMessage(JSON.stringify(jsonObject));

//set the id after recieving it
let id ;

let pc;



// Function to send a message to the server using long polling
async function sendMessage(message) {
  const url = prot + "//" + host;
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'plain/text',
    },
    body: message,
  });
  
  console.log('Message sent successfully');
  if (response.ok) {
    let msg = await response.text(); 
    console.log("Recieved response: "+msg);


    // if(msg.startsWith("{\"icelist")){
      const icelistQueue = extractIcelistValues(msg);
      console.log(icelistQueue);
      
      // Example iteration through the icelist queue
      while (icelistQueue.length > 0) {
        const icelistValue = icelistQueue.shift();
        console.log("printing the first"+icelistValue);
        processResponse(icelistValue);
      }
    // }else{  
       processResponse(msg);
    // }
  } else {
    console.error('Failed to send message');
  }
 }

 function processResponse(response){
  console.log(response);

  const res = JSON.parse(response);
  console.log("The object length is "+Object.keys(res).length);
  console.log(res);
  for (let key in res) {
    let result = extractValuesByKey(response, key);
    console.log("The result i got from extraction is: "+result);
    if (res.hasOwnProperty(key)) {
        switch(key){
          case "id":
            if(id == null){
              id = res[key];
              var newDiv = document.createElement("div");
              newDiv.className = "t-item";
              newDiv.textContent = nm;
              sidePanel.appendChild(newDiv);
            }
            break;
          case "noMessage":
              break;
          case "list":
            
            while(result.length > 0){
              var resi = result.shift();
              var rest = resi.split(",");
              for(var i=0; i<rest.length; i++){
                var newDiv = document.createElement("div");
                newDiv.className = "t-item";
                newDiv.textContent = rest[i];
                sidePanel.appendChild(newDiv);
                console.log(newDiv);
              }
            }
            break;
          case "newUser":

            while(result.length > 0){
              var resi = result.shift();
              console.log("new user arrived");
              var newDiv = document.createElement("div");
                newDiv.className = "t-item";
                newDiv.textContent = resi;
                sidePanel.appendChild(newDiv);
            }
              break;
          case "chatMessage":
            while(result.length > 0){
              var resi = result.shift();
              const chat = document.getElementById("chat");
              const pElement = document.createElement("p");
              pElement.textContent = resi;
              chat.appendChild(pElement);
            }
            break;
          case "chatlist":
            while(result.length > 0){
              var resi = result.shift(); 
              var rest = resi.split(",");
              for(var i=0; i<rest.length; i++){
                const chat = document.getElementById("chat");
                const pElement = document.createElement("p");
                pElement.textContent = rest[i];
                chat.appendChild(pElement);
              }
            }
            break;
          case "type":
            if(res[key] == "offer"){
              let details = {type: res.type, sdp: res.sdp};
              handleOffer(details);
            }else if(res[key] == "candidate"){
              let details = {type: res.type, candidate: res.candidate, sdpMid: res.sdpMid, sdpMLineIndex: res.sdpMLineIndex};
              handleIce(details);
            }else if(res[key] == "answer"){
              let answerDetails = {type: 'answer', sdp: res.sdp};
              handleAnswer(answerDetails);
            }
            break;
          case "icelist":
              var rest = res[key];
              while (rest.length > 0) {
                console.log("handling ice from ice list"+ JSON.stringify(rest[0]));
                  handleIce(rest[0]);
                  rest.shift();
              }
            break;         
        }
    }
  }
           
  let noMessage = {id: id, getMessage: "getNewMessage"};
  if(id != null){
    setTimeout(()=>sendMessage(JSON.stringify(noMessage)), 5000);
  }
 }
 function extractIcelistValues(inputString) {
  const icelistQueue = [];

  // Find the index of the first occurrence of '"icelist":['
  let startIndex = inputString.indexOf('"icelist":[');

  // Continue until there are no more occurrences of '"icelist":['
  while (startIndex !== -1) {
    // Find the index of the matching "]}" for the current '"icelist":['
    let endIndex = inputString.indexOf('],', startIndex);

    // If a matching "]}" is found, extract the substring between '"icelist":[' and ']}' (inclusive)
    if (endIndex !== -1) {
      const icelistString = "{"+inputString.substring(startIndex, endIndex + 1)+"}";
      
      // Push the extracted icelist value to the array queue
      icelistQueue.push(icelistString);

      // Find the index of the next occurrence of '"icelist":[' to continue the loop
      startIndex = inputString.indexOf('"icelist":[', endIndex);
    } else {
      break;
    }
  }

  return icelistQueue;
}



 async function setMessage(){
  const chat = document.getElementById("chat");
  const pElement = document.createElement("p");
  let message = document.getElementById("message").value;
  pElement.textContent = nm+": "+message;
  chat.appendChild(pElement);
  let jOb = {id: id, chatMessage: nm+": "+message};
  await sendMessage(JSON.stringify(jOb));

  // Clear the input field
  document.getElementById("message").value = "";
}

const videoHost = document.getElementById("preview");
const lVideo = document.createElement("video");
lVideo.setAttribute("id", "video");
videoHost.appendChild(lVideo);

const localVideo = document.getElementById('video');

let iceCandidateQueue = [];
let isOfferSet = false;

const box = document.getElementById("preview-control");
      // Create "Start" button
      const start = document.createElement("button");
      start.setAttribute("id", "startButton");
      start.title = "Start";  // Use '=' to set the title property
      start.textContent = "Start";  // Use '=' to set the text content
      box.appendChild(start);

      
const startButton = document.getElementById('startButton');
startButton.onclick = async () => {
  sendMessage(JSON.stringify({id: id, ready: id}));
}
async function handleOffer(offer){
  if(!pc){
    pc = new RTCPeerConnection(configuration);
  }
  pc.setRemoteDescription(offer);
  iceListener();
  console.log("Got offer.");
  isOfferSet = true;
  pc.ontrack = (e) => {
    console.log("ontrack event:", e);
  
    const firstStream = e.streams[0];
    console.log("Received Stream:", firstStream);

    firstStream.getTracks().forEach((track) => {
      console.log("Track kind:", track.kind);
    }); 
  
  let isStreamSet = false;

  if (firstStream) {
    
    // Check if the stream is already set
    if (!isStreamSet) {
      console.log("Setting the source object");
      localVideo.srcObject = firstStream;
      isStreamSet = true;
      
      localVideo.setAttribute("preload", "auto");
       // Wait for the canplay event before attempting to play
       localVideo.oncanplay = () => {
        // Create "Play" button
        const player = document.createElement("button");
        player.setAttribute("id", "startButton");
        player.title = "Play";
        player.textContent = "Play";
        box.appendChild(player);
      
        player.onclick = async () => { // Fix syntax error here
          try {
            await localVideo.play(); // Fix syntax error here
            console.log("Video playback started successfully");
          } catch (error) {
            console.error("Error starting video playback:", error);
          }
        };
      };
    };
    // } else {
    //   console.log("Stream is already set. Skipping setting it again.");
    // }
  } else {
    console.error("No streams found in the event.");
  }
}
    const answer = await pc.createAnswer();
    console.log("Sending Answer: "+JSON.stringify({type: answer.type, sdp: answer.sdp}));
    await sendMessage(JSON.stringify({id: id, type: 'answer', sdp: answer.sdp}));
    await pc.setLocalDescription(answer);
}
function iceListener(){
  console.log("before the ice starts listening for candidates"); 
    pc.onicecandidate = e => {
      console.log("getting ice candidate");
      // Check if e.candidate is not null
      if (e.candidate) {
        const message = {
            id: id,
            type: 'candidate',
            candidate: e.candidate.candidate,
            sdpMid: e.candidate.sdpMid,
            sdpMLineIndex: e.candidate.sdpMLineIndex,
        };
  
        console.log("got ice candidate: " + JSON.stringify(message));
        setTimeout(async ()=>await sendMessage(JSON.stringify(message)), 5000);
        
      }
    };
}

function handleIce(ice){
  if(!pc){
    pc = new RTCPeerConnection(configuration);
  }
  if(pc.remoteDescription){
    console.log("adding ice to RTCConnection");
    pc.addIceCandidate(ice);
  }else{
    console.log("adding ice to queue");
    iceCandidateQueue.push(ice);
  }
}
//set timeout to check for offer being set
let timer = setInterval(checkOffer,5000);
function checkOffer(){
  console.log("Starting ice timer");
  if(isOfferSet){     
      if (iceCandidateQueue.length > 0) {
        console.log('Processing '+iceCandidateQueue.length+' queued');
        // Iterate through the array without modifying it during the loop
        for (let i = 0; i < iceCandidateQueue.length; i++) {
            handleIce(iceCandidateQueue[i]);
        }
    
        // Clear the array after processing all elements
        iceCandidateQueue.length = 0;
      }else{
        console.log("Clearing the interval of ice");
       clearInterval(timer);
      }
    }
  }
  function extractValuesByKey(jsonString, key) {
    const valuesArray = [];
    const regex = new RegExp(`"${key}"\\s*:\\s*("(.*?)"|\\d*|true|false|null)`, 'g');
    let match;
  
    while ((match = regex.exec(jsonString)) !== null) {
      const [, value] = match[0].match(/:\s*"(.*)"/) || [, match[0]];
      valuesArray.push(value);
    }
  
    return valuesArray;
  }

  